//#define ENCODER_DO_NOT_USE_INTERRUPTS 
#include "Encoder.h"
#include "LibPrintf.h"
#include <util/atomic.h>

// constants won't change
const int PWM_PIN = 8, MOTOR_QWP230_IN = 36, MOTOR_QWP230_OUT = 37, MOTOR_QWP230_ROT_CW = 41, MOTOR_QWP230_ROT_CCW = 40, LATERAL_QWP230_ENCPIN_A = 48, LATERAL_QWP230_ENCPIN_B = 46; 

const int FLAG_QWP230_OUT = 29 /*HOME SWITCH*/, FLAG_QWP230_IN = 30 /*EX SWITCH*/,FLAG_QWP230_ENC = 31 /*ROT SWITCH*/;
const long LIMIT_HOME = 0; //HOME Limit
const long LIMIT_EX = 33000; //EX Limit

long userInput;
int pullup; 
volatile int newPos = 0;
float deltT = 10, u = 0, vmax = 2500, a = 6000; 
float oldPos, dist, tolm, tolp, startT, setPoint, oldPosStart, lastPrintTime;
float t, ta, tb, totT, er, eri, ederiv, einteg, speed, x;  
bool hasHomed = false;

Encoder myEnc(LATERAL_QWP230_ENCPIN_A, LATERAL_QWP230_ENCPIN_B);

//PID constants
float kp = 3.0; // d Tr, i O, d Ts, d SSE lower
float ki = 0.05; // d Tr, i O, i Ts, elim SSE higher
float kd = 0.2; // sd Tr, d O, d Ts, N/A SSE lower

void setup() {

  pinMode(PWM_PIN, OUTPUT);
  pinMode(MOTOR_QWP230_IN, OUTPUT);
  pinMode(MOTOR_QWP230_OUT, OUTPUT);
  pinMode(FLAG_QWP230_IN, INPUT_PULLUP);
  pinMode(FLAG_QWP230_OUT, INPUT_PULLUP);

  Serial.begin(230400);
  delay(1000);
  Serial.println("Enter Target Position");

  while(!Serial); 
}

void loop() {
  if (Serial.available()) {
    String inputStr = Serial.readStringUntil('\n');  // read a line from Serial
    inputStr.trim();  // remove whitespace

    if (inputStr.equalsIgnoreCase("H")) {
      userInput = 1;  // If user typed H or h, set userInput = 1
    } else {
      long temp = inputStr.toInt();  // convert input string to int
      userInput = constrain(temp, LIMIT_HOME, LIMIT_EX);
    }

    // proceed even if temp == 0
    Serial.print(" Target Pos: ");
    Serial.print(userInput);
    oldPosStart = myEnc.read();
    Serial.print("   Current Pos: ");
    Serial.println(oldPosStart);

    dist = (float)(userInput - oldPosStart);
    tolm = userInput - 1;
    tolp = userInput + 1;

    startT = micros();
    vProf(dist);
    float endT = micros();
    float totalDurationSec = (endT - startT) / 1.0e6;

    setPoint = 0;

    digitalWrite(MOTOR_QWP230_IN, HIGH);
    digitalWrite(MOTOR_QWP230_OUT, HIGH);
    analogWrite(PWM_PIN, 0);

    delay(1000);

    if (digitalRead(FLAG_QWP230_OUT) == HIGH) {
      Serial.println(": HOME Flag");
    }
    if (digitalRead(FLAG_QWP230_IN) == HIGH) {
      Serial.println(": EX Flag");
    }

    oldPosStart = myEnc.read();
    Serial.print(" Final Pos: ");
    Serial.print(oldPosStart);
    Serial.print(" kp*e: ");
    Serial.print(kp*er);
    Serial.print(" ki*e: ");
    Serial.print(ki*einteg);
    Serial.print(" kd*e: ");
    Serial.print(kd*ederiv);
    Serial.print(" speed: ");
    Serial.println(speed);
    Serial.print(" Target Pos: ");
    Serial.println(userInput);

    while (Serial.available()) Serial.read();

    Serial.println("Enter Target Position");
  }
}


void vProf(float distance) {
  ta = (float)vmax / a;
  totT = (abs(distance)*a + vmax*vmax) / (a*vmax);
  tb = totT - 2*ta;
  t = (float)(micros() - startT)/(1.0e6);

  static unsigned long lastPrintTime = 0;

  while ((abs(newPos - userInput) >= 1) && abs(setPoint - userInput) >= 1 && t < 10){
    newPos = myEnc.read();
    if (t < ta) {
      x = (0.5*a*t*t);
    }
    else if (t >= ta && t < ta + tb) {
      x = (0.5*a*ta*ta + vmax*(t - ta));
    }
    else {
      x = (0.5*a*ta*ta + vmax*tb + vmax*(t - ta - tb) - 0.5*a*(t - ta - tb)*(t - ta - tb));
    }

    t = (float)(micros() - startT)/(1.0e6); 

    // FLAG LIMIT TRIGGERS
    if (hasHomed && (digitalRead(FLAG_QWP230_OUT) == LOW || digitalRead(FLAG_QWP230_IN) == LOW)) {
      digitalWrite(MOTOR_QWP230_IN, LOW);
      digitalWrite(MOTOR_QWP230_OUT, LOW);
      analogWrite(PWM_PIN, 0);
      return;
    }

    setPoint = oldPosStart + (distance >= 0 ? x : -x);

    PIDcalc(setPoint);

  }
  
  digitalWrite(MOTOR_QWP230_IN, LOW); // control motor A stops
  digitalWrite(MOTOR_QWP230_OUT, LOW);  // control motor A stops
  analogWrite(PWM_PIN, 0);

}

void PIDcalc(float setpoint) {

  newPos = myEnc.read();
  er = abs(setpoint - newPos);
  ederiv = (er - eri) / deltT;
  einteg = einteg + er * deltT;

  u = kp*er + ki*einteg + kd*ederiv;

  if (t < ta) {
    speed = constrain(u, 30, 255);
  }
  else {
    speed = constrain(u, 0, 255);
  }
  
  analogWrite(PWM_PIN, speed);
  motorMove(setpoint);

  if (millis() - lastPrintTime >= 1000) {
    lastPrintTime = millis();
    Serial.print(" Position: ");
    Serial.print(newPos);
   /*Serial.print(" kp*e: ");
    Serial.print(kp*er);
    Serial.print(" ki*e: ");
    Serial.print(ki*einteg);
    Serial.print(" kd*e: ");
    Serial.print(kd*ederiv);*/
    Serial.print(" speed: ");
    Serial.println(speed);

  }

  eri = er;
  er = 0;
  ederiv = 0;
  einteg = 0;

}

void motorMove(float setpoint) {

  newPos = (float) myEnc.read();

  if (setpoint - newPos > 1) {
    digitalWrite(MOTOR_QWP230_IN, HIGH); // control motor A spins clockwise
    digitalWrite(MOTOR_QWP230_OUT, LOW);  // control motor A spins clockwise
  }

  else if (setpoint - newPos < -1) {  
    digitalWrite(MOTOR_QWP230_IN, LOW); // control motor A spins counterclockwise
    digitalWrite(MOTOR_QWP230_OUT, HIGH);  // control motor A spins counterclockwise

  }

  else {
    digitalWrite(MOTOR_QWP230_IN, LOW); // control motor A stops
    digitalWrite(MOTOR_QWP230_OUT, LOW);  // control motor A stops

  }

}
